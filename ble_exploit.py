#!/usr/bin/env python3
# This script is a modified version of the original BLE script from https://github.com/hexway/apple_bleee.git
# The original script was modified to add a new feature:
# - Chained with OWL for AWDL 802.11 handshake capture (to find the MAC addresses of devices)
# - Integrates BLE triggers to activate and capture AWDL frames (e.g., Action Frames with TLVs)
# And was also updated to work with the latest versions of iOS and MacOS.
# Author: Erik Peterson


import random
import re
import sys
import time
import json
import curses
import hashlib
import urllib3
import requests
import argparse
import npyscreen
import subprocess
from os import path
import subprocess
import threading
import time
import os
import signal
import json


from prettytable import PrettyTable
from threading import Thread, Timer
import bluetooth._bluetooth as bluez
from utils.bluetooth_utils import (toggle_device, enable_le_scan, parse_le_advertising_events, disable_le_scan,
                                  raw_packet_to_str, start_le_advertising, stop_le_advertising)


# New imports for chaining
import os
import signal  # For killing subprocesses


help_desc = '''
Apple bleee. Apple device sniffer with chained AWDL 802.11 capture using OWL.
Triggers OWL/tcpdump on BLE events (e.g., AirDrop/WiFi join) to capture handshakes.
---chipik (enhanced for multi-vector exploit)
'''
urllib3.disable_warnings()
parser = argparse.ArgumentParser(description=help_desc, formatter_class=argparse.RawTextHelpFormatter)


parser.add_argument('-s', '--ssid', action='store_true', help='Get SSID from requests')


parser.add_argument('-a', '--airdrop', action='store_true', help='Get info from AWDL with chained OWL capture')
parser.add_argument('-d', '--active', action='store_true', help='Get devices names (gatttool)')
parser.add_argument('-v', '--verb', help='Verbose output. Filter actions (All, Nearby, Handoff, etc)')
parser.add_argument('-t', '--ttl', type=int, default=15, help='ttl')
parser.add_argument('-i', '--interface', default='wlan0', help='WiFi interface for OWL/tcpdump (e.g., wlan0)')
parser.add_argument('--capture_duration', type=int, default=300, help='AWDL capture duration in seconds')
args = parser.parse_args()

# Validate conflicting flags
if args.airdrop and args.verb:
    print("Error: Cannot use both -a (airdrop) and -v (verbose) flags together.")
    print("Please choose either -a for airdrop mode or -v for verbose mode, but not both.")
    sys.exit(1)

def detect_wifi_interface():
    """Try to detect the correct WiFi interface on Linux systems"""
    try:
        import subprocess
        import re
        
        # Method 1: Use iwconfig to find wireless interfaces
        try:
            result = subprocess.run(['iwconfig'], capture_output=True, text=True, stderr=subprocess.DEVNULL)
            if result.returncode == 0:
                # Find interfaces that have "IEEE 802.11" (wireless)
                wireless_interfaces = re.findall(r'^(\w+)\s+IEEE 802.11', result.stdout, re.MULTILINE)
                if wireless_interfaces:
                    return wireless_interfaces[0]  # Return first found
        except FileNotFoundError:
            pass
        
        # Method 2: Check /sys/class/net for wireless interfaces
        try:
            import os
            for interface in os.listdir('/sys/class/net/'):
                wireless_path = f'/sys/class/net/{interface}/wireless'
                if os.path.exists(wireless_path):
                    return interface
        except (OSError, FileNotFoundError):
            pass
        
        # Method 3: Use ip command to find interfaces with "wl" prefix
        try:
            result = subprocess.run(['ip', 'link', 'show'], capture_output=True, text=True)
            if result.returncode == 0:
                # Look for common wireless interface patterns
                wireless_patterns = re.findall(r'\d+:\s+(wl\w*|wlan\d+|wlp\w+):', result.stdout)
                if wireless_patterns:
                    return wireless_patterns[0]
        except FileNotFoundError:
            pass
            
        # Fallback to common names
        common_names = ['wlan0', 'wlp3s0', 'wlo1', 'wlx0', 'wifi0']
        for name in common_names:
            try:
                result = subprocess.run(['ip', 'link', 'show', name], capture_output=True, stderr=subprocess.DEVNULL)
                if result.returncode == 0:
                    return name
            except FileNotFoundError:
                pass
                
    except Exception:
        pass
    
    return None

if args.airdrop:
   # AirDrop-only mode - focus on AWDL/AirDrop activity exclusively
   print("AirDrop mode: AWDL/AirDrop monitoring only")
   print("Normal BLE state monitoring disabled in AirDrop mode")
   
   # Try to auto-detect WiFi interface if default doesn't work
   if args.interface == 'wlan0':  # Only if using default
       detected_interface = detect_wifi_interface()
       if detected_interface and detected_interface != 'wlan0':
           print(f"Auto-detected WiFi interface: {detected_interface}")
           args.interface = detected_interface




iwdev = 'wlan0'
apple_company_id = 'ff4c00'


dev_id = 1  # the bluetooth device is hci0
toggle_device(dev_id, True)


sock = 0
# Column titles - different for verbose mode
if args.verb:
    titles = ['Mac', 'State', 'Device', 'WI-FI', 'Time', 'Notes']  # No OS column in verbose mode
else:
    titles = ['Mac', 'State', 'Device', 'WI-FI', 'OS', 'Time', 'Notes']
dev_sig = {'02010': 'MacBook', '02011': 'iPhone'}
dev_types = ["iPad", "iPhone", "MacOS", "AirPods", "Powerbeats3", "BeatsX", "Beats Solo3"]
phones = {}
resolved_devs = []
resolved_macs = []
verb_messages = []
dictOfss = {}
proxies = {}
verify = False
victims = []  # Add missing victims list


phone_states = {
   '01': 'Disabled',
   '03': 'Idle',
   '05': 'Music',
   '07': 'Lock screen',
   '09': 'Video',
   '0a': 'Home screen',
   '4a': 'Home screen',
   '00': 'Macbook closed',
   '0b': 'Home screen',
   '0d': 'Driving',
   '0e': 'Incoming call',
   '11': 'Home screen',
   '13': 'Off',
   '17': 'Lock screen',
   '18': 'Off',
   '1a': 'Off',
   '1b': 'Home screen',
   '1c': 'Home screen',
   '23': 'Off',
   '47': 'Lock screen',
   '4b': 'Home screen',
   '4e': 'Outgoing call',
   '57': 'Lock screen',
   '5a': 'Off',
   '5b': 'Home screen',
   '5e': 'Outgoing call',
   '67': 'Lock screen',
   '6b': 'Home screen',
   '6e': 'Incoming call',
   '34': 'Off',
   '32': 'Off',
   '70': 'Lock Screen',
   '76': 'Lock Screen',
   '3c': 'Turning Off',
   '7c': 'Home Screen',
   '7a': 'Home Screen',
}


airpods_states = {
   '00': 'Case:Closed',
   '01': 'Case:All out',
   '02': 'L:out',
   '03': 'L:out',
   '05': 'R:out',
   '09': 'R:out',
   '0b': 'LR:in',
   '11': 'R:out',
   '13': 'R:in',
   '15': 'R:in case',
   '20': 'L:out',
   '21': 'Case:All out',
   '22': 'Case:L out',
   '23': 'R:out',
   '29': 'L:out',
   '2b': 'LR:in',
   '31': 'Case:L out',
   '33': 'Case:L out',
   '50': 'Case:open',
   '51': 'L:out',
   '53': 'L:in',
   '55': 'Case:open',
   '70': 'Case:open',
   '71': 'Case:R out',
   '73': 'Case:R out',
   '75': 'Case:open',
}

proximity_dev_models = {
   '0220': 'AirPods',
   '0320': 'Powerbeats3',
   '0520': 'BeatsX',
   '0620': 'Beats Solo3'
}


proximity_colors = {
   '00': 'White',
   '01': 'Black',
   '02': 'Red',
   '03': 'Blue',
   '04': 'Pink',
   '05': 'Gray',
   '06': 'Silver',
   '07': 'Gold',
   '08': 'Rose Gold',
   '09': 'Space Gray',
   '0a': 'Dark Blue',
   '0b': 'Light Blue',
   '0c': 'Yellow',
}


homekit_category = {
   '0000': 'Unknown',
   '0100': 'Other',
   '0200': 'Bridge',
   '0300': 'Fan',
   '0400': 'Garage Door Opener',
   '0500': 'Lightbulb',
   '0600': 'Door Lock',
   '0700': 'Outlet',
   '0800': 'Switch',
   '0900': 'Thermostat',
   '0a00': 'Sensor',
   '0b00': 'Security System',
   '0c00': 'Door',
   '0d00': 'Window',
   '0e00': 'Window Covering',
   '0f00': 'Programmable Switch',
   '1000': 'Range Extender',
   '1100': 'IP Camera',
   '1200': 'Video Doorbell',
   '1300': 'Air Purifier',
   '1400': 'Heater',
   '1500': 'Air Conditioner',
   '1600': 'Humidifier',
   '1700': 'Dehumidifier',
   '1c00': 'Sprinklers',
   '1d00': 'Faucets',
   '1e00': 'Shower Systems',
}


siri_dev = {
   '0002': 'iPhone',
   '0003': 'iPad',
   '0009': 'MacBook',
   '000a': 'Watch',
}


magic_sw_wrist = {
   '03': 'Not on wrist',
   '1f': 'Wrist detection disabled',
   '3f': 'On wrist',
}


hotspot_net = {
   '01': '1xRTT',
   '02': 'GPRS',
   '03': 'EDGE',
   '04': '3G (EV-DO)',
   '05': '3G',
   '06': '4G',
   '07': 'LTE',
}


ble_packets_types = {
   'airprint': '03',
   'airdrop': '05',
   'homekit': '06',
   'airpods': '07',
   'siri': '08',
   'airplay': '09',
   'nearby': '10',
   'watch_c': '0b',
   'handoff': '0c',
   'wifi_set': '0d',
   'hotspot': '0e',
   'wifi_join': '0f',
}


class App(npyscreen.StandardApp):
   def onStart(self):
       self.addForm("MAIN", MainForm, name="Apple devices scanner")


class MyGrid(npyscreen.GridColTitles):
   def custom_print_cell(self, actual_cell, cell_display_value):
       if 'Off' in cell_display_value or '<error>' in cell_display_value or 'iOS10' in cell_display_value or 'iOS11' in cell_display_value or 'Disabled' in cell_display_value:
           actual_cell.color = 'DANGER'
       elif 'Home screen' in cell_display_value or 'On' in cell_display_value or cell_display_value[0:3] in '\n'.join(
               dev_types) or 'X' in cell_display_value or 'Calling' in cell_display_value or cell_display_value in airpods_states.values() or 'WatchOS' in cell_display_value or 'Watch' in cell_display_value or 'iOS13' in cell_display_value or 'Connecting' in cell_display_value or 'WiFi screen' in cell_display_value or 'Incoming' in cell_display_value or 'Outgoing' in cell_display_value or 'Siri' in cell_display_value or 'Idle' in cell_display_value:
           actual_cell.color = 'GOOD'
       elif 'Lock screen' in cell_display_value or 'iOS12' in cell_display_value:
           actual_cell.color = 'CONTROL'
       else:
           actual_cell.color = 'DEFAULT'


class OutputBox(npyscreen.BoxTitle):
   _contained_widget = npyscreen.MultiLineEdit


class VerbOutputBox(npyscreen.BoxTitle):
   _contained_widget = npyscreen.MultiLineEdit


class MainForm(npyscreen.FormBaseNew):
   def create(self):
       global logFile
       new_handlers = {
           "^Q": self.exit_func
       }
       self.add_handlers(new_handlers)
       y, x = self.useable_space()
       if args.airdrop or args.verb:
           self.gd = self.add(MyGrid, col_titles=titles, column_width=20, max_height=y // 2)
       else:
           self.gd = self.add(MyGrid, col_titles=titles, column_width=20)
       
       if args.airdrop:
           self.OutputBox = self.add(OutputBox, editable=False)
       if args.verb:
           self.VerbOutputBox = self.add(VerbOutputBox, editable=False, name=logFile)
       self.gd.values = []
       self.gd.add_handlers({curses.ascii.NL: self.upd_cell})


   def while_waiting(self):
       self.gd.values = print_results()
       if args.airdrop:
           self.OutputBox.value = print_wifi_devs()
           self.OutputBox.display()
       if args.verb:
           self.VerbOutputBox.value = pop_verb_messages()
           self.VerbOutputBox.display()
       if args.active:
           self.get_all_dev_names()


   def exit_func(self, _input):
        disable_le_scan(sock)
        print(f"[{time.strftime('%H:%M:%S')}] Exiting. Logging connected devices to {real_mac_log}...")
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Exit Log:\n")
            f.write(f"Connected BLE MACs (AirDrop/WiFi join): {', '.join(connected_macs) or 'None'}\n")
            f.write(f"Check {pcap_file} and previous logs for real MACs.\n")
            f.write("-" * 50 + "\n")
        if capture_running:
            stop_awdl_capture(0)
        print("Bye")
        sys.exit()


   def get_dev_name(self, mac_addr):
       global resolved_devs
       dev_name = ''
       kill = lambda process: process.kill()
       cmd = ['gatttool', '-t', 'random', '--char-read', '--uuid=0x2a24', '-b', mac_addr]
       proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
       timer = Timer(3, kill, [proc])
       try:
           timer.start()
           dev_name, stderr = proc.communicate()
       finally:
           timer.cancel()
       if dev_name:
           try:
               d_n_hex = dev_name.split(b"value:")[1].replace(b" ", b"").replace(b"\n", b"")
               d_n_str = bytes.fromhex(d_n_hex.decode("utf-8")).decode('utf-8')
            #    return_value = devices_models.get(d_n_str, '')
           except (IndexError, ValueError):
               return_value = ''
       else:
           return_value = ''
       init_bluez()
       resolved_devs.append(mac_addr)
       if return_value:
           self.set_device_val_for_mac(mac_addr, return_value)


   def get_all_dev_names(self):
       global resolved_devs
       for phone in phones:
           if (phones[phone]['device'] == 'MacBook' or phones[phone]['device'] == 'iPhone') and phone not in resolved_devs:
               self.get_dev_name(phone)


   def get_mac_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][0]


   def get_state_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][1]


   def get_device_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][2]


   def get_wifi_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][3]


   def get_os_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][4]


   def get_time_val_from_cell(self):
       return self.gd.values[self.gd.edit_cell[0]][5]


   def set_mac_val_for_mac(self, mac, value):
       global phones
       phones[mac]['mac'] = value


   def set_state_val_for_mac(self, mac, value):
       global phones
       phones[mac]['state'] = value


   def set_device_val_for_mac(self, mac, value):
       global phones
       phones[mac]['device'] = value


   def set_time_val_for_mac(self, mac, value):
       global phones
       phones[mac]['time'] = value


   def get_cell_name(self):
       return titles[self.gd.edit_cell[1]]


   def upd_cell(self, argument):
       global resolved_devs
       cell = self.get_cell_name()
       if cell == 'Device':
           mac = self.get_mac_val_from_cell()
           thread2 = Thread(target=self.get_dev_name, args=(mac,))
           thread2.daemon = True
           thread2.start()


def clear_zombies():
   zombies = []
   cur_time = int(time.time())
   for k in list(phones):
       if cur_time - phones[k]['time'] > args.ttl:
           del phones[k]
           if resolved_macs.count(k):
               resolved_macs.remove(k)
           if resolved_devs.count(k):
               resolved_devs.remove(k)
           if victims.count(k):
               victims.remove(k)


def print_results():
   rez_str = ''
   clear_zombies()
   row = []
   
   if args.airdrop:
       # AirDrop mode: Only show AWDL/AirDrop related devices
       for phone in phones:
           device_state = phones[phone]['state']
           device_notes = phones[phone]['notes']
           
           # Only show devices with AirDrop, WiFi join, or AirPlay activity
           if (device_state == 'AirDrop' or 
               'WiFi join detected' in device_notes or 
               device_state == 'AirPlay' or
               'AirDrop activity detected' in device_notes):
               
               if args.verb:
                   # Verbose mode: No OS column
                   row.append([phone, phones[phone]['state'], phones[phone]['device'], phones[phone]['wifi'],
                              phones[phone]['time'], phones[phone]['notes']])
               else:
                   # Normal AirDrop mode: Include OS column
                   row.append([phone, phones[phone]['state'], phones[phone]['device'], phones[phone]['wifi'], phones[phone]['os'],
                              phones[phone]['time'], phones[phone]['notes']])
   else:
       # Normal mode: Show all devices
       for phone in phones:
           if args.verb:
               # Verbose mode: No OS column
               row.append([phone, phones[phone]['state'], phones[phone]['device'], phones[phone]['wifi'],
                          phones[phone]['time'], phones[phone]['notes']])
           else:
               # Normal mode: Include OS column
               row.append([phone, phones[phone]['state'], phones[phone]['device'], phones[phone]['wifi'], phones[phone]['os'],
                          phones[phone]['time'], phones[phone]['notes']])
   
   return row


def parse_struct(data, struct):
   result = {}
   i = 0
   for key in struct:
       if key == 999:
           result[key] = data[i:]
       else:
           if i + struct[key] * 2 <= len(data):
               result[key] = data[i:i + struct[key] * 2]
           else:
               result[key] = data[i:] if i < len(data) else ''
       i = i + struct[key] * 2
   return result


def parse_os_wifi_code(code, dev):
   if code == '1c':
       if dev == 'MacBook':
           return ('Mac OS', 'On')
       else:
           return ('iOS12', 'On')
   elif code == '18':
       if dev == 'MacBook':
           return ('Mac OS', 'Off')
       else:
           return ('iOS12', 'Off')
   elif code == '10':
       return ('iOS11', '<unknown>')
   elif code == '1e':
       return ('iOS13', 'On')
   elif code == '1a':
       return ('iOS13', 'Off')
   elif code == '0e':
       return ('iOS13', 'Connecting')
   elif code == '0c':
       return ('iOS12', 'On')
   elif code == '04':
       return ('iOS13', 'On')
   elif code == '00':
       return ('iOS10', '<unknown>')
   elif code == '09':
       return ('Mac OS', '<unknown>')
   elif code == '14':
       return ('Mac OS', 'On')
   elif code == '98':
       return ('WatchOS', '<unknown>')
   else:
       return ('', '')


def parse_ble_packet(data):
   parsed_data = {}
   tag_len = 2
   i = 0
   while i < len(data):
       tag = data[i:i + tag_len]
       try:
           val_len = int(data[i + tag_len:i + tag_len + 2], 16)
           value_start_position = i + tag_len + 2
           value_end_position = i + tag_len + 2 + val_len * 2
           if value_end_position <= len(data):
               parsed_data[tag] = data[value_start_position:value_end_position]
           else:
               parsed_data[tag] = data[value_start_position:]
           i = value_end_position
       except (ValueError, IndexError):
           break
   return parsed_data


def put_verb_message(msg, mac):
   if args.verb:
       action = msg[:msg.find(":")]
       if action.lower() in args.verb.lower().split(",") or "all" in args.verb.lower():
           f = open(logFile, 'a+')
           f.write(f"{mac} {msg}\n")
           f.close()
           verb_messages.append(f"{mac} {msg}")


def parse_nearby(mac, header, data):
   if len(data) < 2:  # Minimum length check
       put_verb_message(f"Nearby:Invalid data length {len(data)}", mac)
       return
   nearby = {'status': 1, 'wifi': 1, 'authTag': 999}
   if len(data) >= 4:  # Ensure enough data for status and wifi
       result = parse_struct(data, nearby)
       put_verb_message(f"Nearby:{json.dumps(result)}", mac)
       state = os_state = wifi_state = unkn = '<unknown>'
       if args.verb:
           state = os_state = wifi_state = unkn = f'<unknown>({result["status"]})'
       if result['status'] in phone_states.keys():
           state = phone_states[result['status']]
           if args.verb:
               state = f'{phone_states[result["status"]]}({result["status"]})'
       
       # Enhanced device detection based on status codes
       dev_val = unkn
       mac_states = ['0a', '4a', '00']  # MacBook state codes
       iphone_states = ['34', '70', '3c', '7c']  # iPhone state codes
       
       # Detect device type based on status code
       if result['status'] in mac_states:
           dev_val = 'MacBook'
       elif result['status'] in iphone_states:
           dev_val = 'iPhone'
       else:
           # Fallback to original header-based detection
           for dev in dev_sig:
               if dev in header:
                   dev_val = dev_sig[dev]
       
       os_state, wifi_state = parse_os_wifi_code(result['wifi'], dev_val)
       
       # Enhanced WiFi state detection
       if result['wifi'] == '1d':
           wifi_state = 'WiFi On'
       elif result['wifi'] == '19':
           wifi_state = 'WiFi Off'
       elif args.verb:
           wifi_state = f'{wifi_state}({result["wifi"]})'
       
       if os_state == 'WatchOS':
           dev_val = 'Watch'
           
       if mac in resolved_macs or mac in resolved_devs:
           phones[mac]['state'] = state
           phones[mac]['wifi'] = wifi_state
           phones[mac]['os'] = os_state
           phones[mac]['time'] = int(time.time())
           if mac not in resolved_devs:
               phones[mac]['device'] = dev_val
       else:
           phones[mac] = {'state': unkn, 'device': unkn, 'wifi': unkn, 'os': unkn, 'time': int(time.time()),
                          'notes': ''}
           phones[mac]['device'] = dev_val
           resolved_macs.append(mac)


def parse_nandoff(mac, data):
   if len(data) < 14:  # Minimum length for handoff
       put_verb_message(f"Handoff:Invalid data length {len(data)}", mac)
       return
   handoff = {'clipboard': 1, 's_nbr': 2, 'authTag': 1, 'encryptedData': 10}
   result = parse_struct(data, handoff)
   put_verb_message(f"Handoff:{json.dumps(result)}", mac)
   notes = f"Clbrd:True" if result['clipboard'] == '08' else ''
   if mac in resolved_macs:
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {'state': 'Idle', 'device': 'AppleWatch', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': notes}
       resolved_macs.append(mac)


def parse_watch_c(mac, data):
   if len(data) < 6:  # Minimum length for watch_c
       put_verb_message(f"MagicSwitch:Invalid data length {len(data)}", mac)
       return
   magic_switch = {'data': 2, 'wrist': 1}
   result = parse_struct(data, magic_switch)
   put_verb_message(f"MagicSwitch:{json.dumps(result)}", mac)
   notes = f"{magic_sw_wrist.get(result['wrist'], '<unknown>')}"
   if mac in resolved_macs:
       phones[mac]['state'] = 'MagicSwitch'
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {'state': 'MagicSwitch', 'device': 'AppleWatch', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': notes}
       resolved_macs.append(mac)


def parse_wifi_set(mac, data):
   if len(data) < 8:  # Minimum length for wifi_set
       put_verb_message(f"WiFi settings:Invalid data length {len(data)}", mac)
       return
   wifi_set = {'icloudID': 4}
   result = parse_struct(data, wifi_set)
   put_verb_message(f"WiFi settings:{json.dumps(result)}", mac)
   unkn = '<unknown>'
   if mac in resolved_macs or mac in resolved_devs:
       phones[mac]['state'] = 'WiFi screen'
   else:
       phones[mac] = {'state': unkn, 'device': unkn, 'wifi': unkn, 'os': unkn, 'time': int(time.time())}
       resolved_macs.append(mac)


def parse_hotspot(mac, data):
   if len(data) < 12:  # Minimum length for hotspot
       put_verb_message(f"Hotspot:Invalid data length {len(data)}", mac)
       return
   hotspot = {'version': 1, 'flags': 1, 'battery': 2, 'cell_srv': 1, 'cell_bars': 1}
   result = parse_struct(data, hotspot)
   put_verb_message(f"Hotspot:{json.dumps(result)}", mac)
   notes = hotspot_net.get(result['cell_srv'], '<unknown>')
   if mac in resolved_macs or mac in resolved_devs:
       phones[mac]['state'] = f"{phones[mac]['state']}.Bat:{int(result['battery'], 16)}%"
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {'state': 'MagicSwitch', 'device': 'AppleWatch', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': notes}
       resolved_macs.append(mac)


def parse_wifi_j(mac, data):
   if len(data) < 24:  # Minimum length for wifi_join
       put_verb_message(f"WiFi join:Invalid data length {len(data)}", mac)
       return
   wifi_j = {'flags': 1, 'type': 1, 'tag': 3, 'appleID_hash': 3, 'phone_hash': 3, 'email_hash': 3, 'ssid_hash': 3}
   result = parse_struct(data, wifi_j)
   put_verb_message(f"WiFi join:{json.dumps(result)}", mac)
   unkn = '<unknown>'
  
   if mac in resolved_macs:
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = 'WiFi join detected'
   else:
       phones[mac] = {'state': unkn, 'device': unkn, 'wifi': unkn, 'os': unkn,
                      'time': int(time.time()), 'notes': 'WiFi join detected'}
       resolved_macs.append(mac)
  
   # WiFi join activity detected - log for monitoring
   # Rate limit the messages to avoid spam
   current_time = time.time()
   if mac not in last_airdrop_message_time or (current_time - last_airdrop_message_time[mac]) > airdrop_message_cooldown:
        current_time = time.time()
        if not args.airdrop and (mac not in last_capture_time or (current_time - last_capture_time[mac]) > capture_cooldown):
            connected_macs.add(mac)  # Mark as connected
            print(f"Chaining to AWDL capture for real MAC discovery on {mac}")
            start_awdl_capture()
            last_capture_time[mac] = current_time


def parse_airpods(mac, data):
   if len(data) < 50:  # Minimum length for airpods (25 bytes * 2 for hex)
       put_verb_message(f"AirPods:Invalid data length {len(data)}", mac)
       return
   airpods = {
       'fix1': 1,
       'model': 2,
       'utp': 1,
       'battery1': 1,
       'battery2': 1,
       'lid_counter': 1,
       'color': 1,
       'fix2': 1,
       'encr_data': 999  # Variable length
   }
   result = parse_struct(data, airpods)
   put_verb_message(f"AirPods:{json.dumps(result)}", mac)
   state = unkn = '<unknown>'
   try:
       bat1 = "{:08b}".format(int(result['battery1'], base=16))
       bat2 = "{:08b}".format(int(result['battery2'], base=16))
       bat_left = int(bat1[:4], 2) * 10
       bat_right = int(bat1[4:], 2) * 10
       color = proximity_colors.get(result['color'], '<unknown>')
       bat_level = f'L:{bat_left}% R:{bat_right}%'
       notes = f'{bat_level} {color}'
       if result['utp'] in airpods_states.keys():
           state = airpods_states[result['utp']]
       elif result['battery1'] == '09':
           state = 'Case:Closed'
   except (KeyError, ValueError):
       state = '<error>'
       notes = '<error>'
   if mac in resolved_macs:
       phones[mac]['state'] = state
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {
           'state': state,
           'device': proximity_dev_models.get(result['model'], 'AirPods'),
           'wifi': '',
           'os': '',
           'phone': '',
           'time': int(time.time()),
           'notes': notes
       }
       resolved_macs.append(mac)


def parse_airdrop_r(mac, data):
   if len(data) < 36:  # Minimum length for airdrop
       put_verb_message(f"AirDrop:Invalid data length {len(data)}", mac)
       return
   airdrop_r = {'zeros': 8, 'st': 1, 'appleID_hash': 2, 'phone_hash': 2, 'email_hash': 2, 'email2_hash': 2, 'zero': 1}
   result = parse_struct(data, airdrop_r)
   put_verb_message(f"AirDrop:{json.dumps(result)}", mac)
   notes = f"phone:{result['phone_hash']}"
   if mac in resolved_macs:
       phones[mac]['state'] = 'AirDrop'
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {'state': 'AirDrop', 'device': '', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': notes}
       resolved_macs.append(mac)
   # AirDrop activity detected - log for monitoring
   # Rate limit the messages to avoid spam during active AirDrop sessions
   current_time = time.time()
   if mac not in last_airdrop_message_time or (current_time - last_airdrop_message_time[mac]) > airdrop_message_cooldown:
        current_time = time.time()
        if not args.airdrop and (mac not in last_capture_time or (current_time - last_capture_time[mac]) > capture_cooldown):
            connected_macs.add(mac)  # Mark as connected
            print(f"Chaining to AWDL capture for real MAC discovery on {mac}")
            start_awdl_capture()
            last_capture_time[mac] = current_time
   # Device info updated in UI automatically


def parse_airprint(mac, data):
   if len(data) < 42:  # Minimum length for airprint
       put_verb_message(f"AirPrint:Invalid data length {len(data)}", mac)
       return
   airpirnt = {'addrType': 1, 'resPathType': 1, 'secType': 1, 'port': 2, 'IP': 16, 'power': 1}
   result = parse_struct(data, airpirnt)
   put_verb_message(f"AirPrint:{json.dumps(result)}", mac)
   if mac in resolved_macs:
       phones[mac]['state'] = 'AirPrint'
       phones[mac]['time'] = int(time.time())
   else:
       phones[mac] = {'state': 'AirPrint', 'device': '', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': ''}
       resolved_macs.append(mac)


def parse_airplay(mac, data):
   if len(data) < 12:  # Minimum length for airplay
       put_verb_message(f"AirPlay:Invalid data length {len(data)}", mac)
       return
   airplay = {'flags': 1, 'configSeeds': 1, 'ipV4': 4}
   result = parse_struct(data, airplay)
   put_verb_message(f"AirPlay:{json.dumps(result)}", mac)
   if mac in resolved_macs:
       phones[mac]['state'] = 'AirPlay'
       phones[mac]['time'] = int(time.time())
   else:
       phones[mac] = {'state': 'AirPlay', 'device': '', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': ''}
       resolved_macs.append(mac)


def parse_homekit(mac, data):
   if len(data) < 4:  # Minimum length for homekit (statusFlag + partial devID)
       put_verb_message(f"Homekit:Invalid data length {len(data)}", mac)
       return
   homekit = {
       'statusFlag': 1,
       'devID': 6,
       'category': 2,
       'globalStateNumber': 2,
       'configurationNumber': 1,
       'compatibleVersion': 1
   }
   result = parse_struct(data, homekit)
   put_verb_message(f"Homekit:{json.dumps(result)}", mac)
   notes = homekit_category.get(result['category'], 'Unknown')
   if mac in resolved_macs:
       phones[mac]['state'] = 'Homekit'
       phones[mac]['time'] = int(time.time())
       phones[mac]['notes'] = notes
   else:
       phones[mac] = {'state': 'Homekit', 'device': '', 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': notes}
       resolved_macs.append(mac)


def parse_siri(mac, data):
   if len(data) < 14:  # Minimum length for siri
       put_verb_message(f"Siri:Invalid data length {len(data)}", mac)
       return
   siri = {'hash': 2, 'SNR': 1, 'confidence': 1, 'devClass': 2, 'random': 1}
   result = parse_struct(data, siri)
   put_verb_message(f"Siri:{json.dumps(result)}", mac)
   if mac in resolved_macs:
       phones[mac]['state'] = 'Siri'
       phones[mac]['time'] = int(time.time())
       phones[mac]['device'] = siri_dev.get(result['devClass'], '<unknown>')
   else:
       phones[mac] = {'state': 'Siri', 'device': siri_dev.get(result['devClass'], '<unknown>'), 'wifi': '', 'os': '',
                      'time': int(time.time()), 'notes': ''}
       resolved_macs.append(mac)


def read_packet(mac, data_str):
   if apple_company_id in data_str:
       header = data_str[:data_str.find(apple_company_id)]
       data = data_str[data_str.find(apple_company_id) + len(apple_company_id):]
       packet = parse_ble_packet(data)
       
       # AirDrop mode: Only process AWDL/AirDrop related packets
       if args.airdrop:
           try:
               # Only process AirDrop, WiFi join, and AirPlay (AWDL-related activities)
               if ble_packets_types['airdrop'] in packet.keys():
                   parse_airdrop_r(mac, packet[ble_packets_types['airdrop']])
               if ble_packets_types['wifi_join'] in packet.keys():
                   parse_wifi_j(mac, packet[ble_packets_types['wifi_join']])
               if ble_packets_types['airplay'] in packet.keys():
                   parse_siri(mac, packet[ble_packets_types['airplay']])
               # Skip all other packet types in AirDrop mode
           except Exception as e:
               put_verb_message(f"Error parsing AirDrop packet for {mac}: {str(e)}", mac)
       else:
           # Normal mode: Process all packet types
           try:
               if ble_packets_types['nearby'] in packet.keys():
                   parse_nearby(mac, header, packet[ble_packets_types['nearby']])
               if ble_packets_types['handoff'] in packet.keys():
                   parse_nandoff(mac, packet[ble_packets_types['handoff']])
               if ble_packets_types['watch_c'] in packet.keys():
                   parse_watch_c(mac, packet[ble_packets_types['watch_c']])
               if ble_packets_types['wifi_set'] in packet.keys():
                   parse_wifi_set(mac, packet[ble_packets_types['wifi_set']])
               if ble_packets_types['hotspot'] in packet.keys():
                   parse_hotspot(mac, packet[ble_packets_types['hotspot']])
               if ble_packets_types['wifi_join'] in packet.keys():
                   parse_wifi_j(mac, packet[ble_packets_types['wifi_join']])
               if ble_packets_types['airpods'] in packet.keys():
                   parse_airpods(mac, packet[ble_packets_types['airpods']])
               if ble_packets_types['airdrop'] in packet.keys():
                   parse_airdrop_r(mac, packet[ble_packets_types['airdrop']])
               if ble_packets_types['airprint'] in packet.keys():
                   parse_airprint(mac, packet[ble_packets_types['airprint']])
               if ble_packets_types['homekit'] in packet.keys():
                   parse_homekit(mac, packet[ble_packets_types['homekit']])
               if ble_packets_types['siri'] in packet.keys():
                   parse_siri(mac, packet[ble_packets_types['siri']])
               if ble_packets_types['airplay'] in packet.keys():
                   parse_siri(mac, packet[ble_packets_types['airplay']])
           except Exception as e:
               put_verb_message(f"Error parsing packet for {mac}: {str(e)}", mac)






def print_wifi_devs():
   """
   Display AirDrop status - safe fallback implementation
   """
   # Simple, safe implementation that doesn't depend on external functions
   try:
       return "AirDrop Mode: Active\nListening for incoming connections...\nDevice should appear in AirDrop lists on Apple devices"
   except:
       return "AirDrop Mode: Active"


def pop_verb_messages():
   global verb_messages
   result = '\n'.join(verb_messages)
   verb_messages = []
   return result






def get_dict_val(dict, key):
   if key in dict:
       return dict[key]
   else:
       return ''


def le_advertise_packet_handler(mac, adv_type, data, rssi):
   data_str = raw_packet_to_str(data)
   read_packet(mac, data_str)


def init_bluez():
   global sock
   try:
       sock = bluez.hci_open_dev(dev_id)
   except:
       print("Cannot open bluetooth device %i" % dev_id)
       raise
   enable_le_scan(sock, filter_duplicates=False)


def do_sniff(prnt):
   global phones
   try:
       parse_le_advertising_events(sock,
                                   handler=le_advertise_packet_handler,
                                   debug=False)
   except KeyboardInterrupt:
       print("Stop")
       disable_le_scan(sock)


def get_hash(data, size=6):
   return hashlib.sha256(data.encode('utf-8')).hexdigest()[:size]


def get_ssids():
   global dictOfss
   proc = subprocess.Popen(['ip', 'link', 'set', iwdev, 'up'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   stdout, stderr = proc.communicate()
   kill = lambda process: process.kill()
   cmd = ['iwlist', iwdev, 'scan']
   proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
   timer = Timer(3, kill, [proc])
   try:
       timer.start()
       ssids, stderr = proc.communicate()
   finally:
       timer.cancel()
   if ssids:
       result = re.findall('ESSID:"(.*)"\n', str(ssids, 'utf-8'))
       ss = list(set(result))
       dictOfss = {get_hash(s): s for s in ss}
   else:
       dictOfss = {}






def start_airdrop_receiver():
   """
   Start OpenDrop-style AirDrop receiver that appears in AirDrop lists
   Based on https://github.com/seemoo-lab/opendrop
   """
   try:
       import subprocess
       import os
       import signal
       import threading
       
       print("Starting OpenDrop-compatible AirDrop receiver...")
       print("This will make your device appear in AirDrop lists on Apple devices")
       print(f"Using interface: {args.interface}")
       
       # Simplified pre-flight checks for OpenDrop-only mode
       print("Pre-flight checks for OpenDrop receiver...")
       
       # Check interface exists (informational only)
       try:
           iface_check = subprocess.run(['ip', 'link', 'show', args.interface], 
                                      capture_output=True, text=True)
           if iface_check.returncode == 0:
               print(f"✓ Interface {args.interface} found")
           else:
               print(f"⚠ Interface {args.interface} not found (OWL should handle this)")
       except Exception as e:
           print(f"⚠ Interface check failed: {e} (OWL should handle this)")
       
       print("Note: Assuming OWL is running with AWDL support in another terminal")
       print("If not, start OWL first: sudo owl -i wlan0 -N")
       
       # Check if opendrop is installed - try multiple locations
       opendrop_cmd = None
       opendrop_found = False
       
       # Try different ways to find opendrop
       sudo_user = os.getenv("SUDO_USER", "")
       current_user = os.getenv("USER", "")
       
       search_paths = [
           'opendrop',  # In PATH
           '/usr/local/bin/opendrop',  # Common system location
           '/home/hst/apple_bleee/venv/bin/opendrop',  # Your specific venv location
       ]
       
       # Add user-specific paths if we have user info
       if sudo_user:
           search_paths.append(f'/home/{sudo_user}/.local/bin/opendrop')
           # Also try venv in user's directory
           search_paths.append(f'/home/{sudo_user}/apple_bleee/venv/bin/opendrop')
       if current_user and current_user != sudo_user:
           search_paths.append(f'/home/{current_user}/.local/bin/opendrop')
           # Also try venv in current user's directory
           search_paths.append(f'/home/{current_user}/apple_bleee/venv/bin/opendrop')
       
       # Also try using python -m if installed as module
       python_module_attempts = [
           ['python3', '-m', 'opendrop', '--help'],
           ['python', '-m', 'opendrop', '--help'],
           ['/usr/bin/python3', '-m', 'opendrop', '--help'],
           ['/home/hst/apple_bleee/venv/bin/python', '-m', 'opendrop', '--help'],  # Your venv python
       ]
       
       # Add venv python paths if we have user info
       if sudo_user:
           python_module_attempts.append([f'/home/{sudo_user}/apple_bleee/venv/bin/python', '-m', 'opendrop', '--help'])
       if current_user and current_user != sudo_user:
           python_module_attempts.append([f'/home/{current_user}/apple_bleee/venv/bin/python', '-m', 'opendrop', '--help'])
       
       print("Searching for OpenDrop installation...")
       
       # Try direct command paths first
       for cmd in search_paths:
           if cmd and os.path.exists(cmd.split()[0] if ' ' not in cmd else cmd):
               try:
                   result = subprocess.run([cmd, '--help'], capture_output=True, text=True)
                   if result.returncode == 0:
                       opendrop_cmd = cmd
                       opendrop_found = True
                       print(f"✓ OpenDrop found at: {cmd}")
                       break
               except Exception:
                   continue
       
       # Try python module approach if direct command failed
       if not opendrop_found:
           for python_cmd in python_module_attempts:
               try:
                   result = subprocess.run(python_cmd, capture_output=True, text=True)
                   if result.returncode == 0:
                       opendrop_cmd = python_cmd[:-1]  # Remove --help
                       opendrop_found = True
                       print(f"✓ OpenDrop found as Python module: {' '.join(python_cmd[:-1])}")
                       break
               except Exception:
                   continue
       
       if not opendrop_found:
           print("✗ OpenDrop not found in any location")
           print("  This might be because you're running with sudo")
           print("  Try one of these solutions:")
           print("  1. Install system-wide: sudo pip3 install opendrop")
           print("  2. Install in user directory: pip3 install --user opendrop")
           print("  3. Use full path to your OpenDrop installation")
           print("Continuing with basic BLE monitoring only...")
           return
       
       # Check if AWDL support is available (OWL)
       try:
           owl_result = subprocess.run(['owl', '--help'], capture_output=True, text=True)
           if owl_result.returncode == 0:
               print("✓ OWL (AWDL support) found")
           else:
               raise FileNotFoundError
       except FileNotFoundError:
           print("✗ OWL (AWDL support) not found")
           print("  Linux AirDrop requires OWL for AWDL protocol support")
           print("  git clone https://github.com/seemoo-lab/owl.git && make install")
           print("  Without OWL, device will not appear in AirDrop lists")
           print("Continuing anyway - may have limited functionality...")
       
       # OWL wrapper - clean AWDL monitoring
       def run_owl_wrapper():
           try:
               print("Starting OWL AWDL Monitor (Clean Mode)")
               print("This will show only meaningful AWDL activity, filtering out noise")
               print(f"Interface: {args.interface}")
               print("=" * 70)
               
               # Start OWL with verbose output
               cmd = ['sudo', 'owl', '-i', args.interface, '-vvv', '-N']
               print(f"Running: {' '.join(cmd)}")
               print("=" * 70)
               
               proc = subprocess.Popen(cmd, 
                                     stdout=subprocess.PIPE, 
                                     stderr=subprocess.PIPE,
                                     text=True, 
                                     bufsize=1,
                                     universal_newlines=True)
               
               # Store process for cleanup
               if not hasattr(run_owl_wrapper, 'processes'):
                   run_owl_wrapper.processes = []
               run_owl_wrapper.processes.append(proc)
               
               print("AWDL ACTIVITY MONITOR:")
               print("=" * 70)
               
               # Track unique peers and their info
               known_peers = {}
               
               # Process OWL output line by line
               for line in proc.stdout:
                   if line.strip():
                       timestamp = time.strftime("%H:%M:%S")
                       
                       # Filter out noise and show only important events
                       if is_important_awdl_event(line):
                           clean_line = parse_awdl_line(line, known_peers)
                           if clean_line:
                               print(f"[{timestamp}] {clean_line}")
                               
                               # Log to file
                               with open('awdl_activity.log', 'a') as f:
                                   f.write(f"[{timestamp}] {clean_line}\n")
                       
           except Exception as e:
               print(f"OWL wrapper error: {e}")
               print("Make sure OWL is installed and you have sudo privileges")
       
       # Helper function to filter important AWDL events
       def is_important_awdl_event(line):
           # Skip all the noise
           skip_patterns = [
               "not handling Unknown",
               "not handling Service Parameters", 
               "not handling HT Capabilities",
               "not handling VHT Capabilities",
               "send PSF",
               "send MIF"
           ]
           
           for pattern in skip_patterns:
               if pattern in line:
                   return False
           
           # Keep important events
           important_patterns = [
               "receive PSF from",
               "peer",
               "changed channel sequence",
               "remove peer",
               "add peer",
               "INFO",
               "WARN",
               "ERROR",
               "Sync error"
           ]
           
           for pattern in important_patterns:
               if pattern in line:
                   return True
                   
           return False
       
       # Helper function to parse and clean AWDL lines
       def parse_awdl_line(line, known_peers):
           import re
           
           # Parse PSF reception
           psf_match = re.search(r'receive PSF from ([a-f0-9:]{17}) \(rssi (-?\d+)\)', line)
           if psf_match:
               mac = psf_match.group(1)
               rssi = psf_match.group(2)
               
               # Track peer info
               if mac not in known_peers:
                   known_peers[mac] = {'first_seen': time.time(), 'rssi': rssi}
                   return f"🔍 NEW AWDL PEER: {mac} (RSSI: {rssi} dBm)"
               else:
                   # Only show if RSSI changed significantly
                   old_rssi = int(known_peers[mac]['rssi'])
                   new_rssi = int(rssi)
                   if abs(old_rssi - new_rssi) > 5:
                       known_peers[mac]['rssi'] = rssi
                       return f"📶 PEER SIGNAL: {mac} (RSSI: {rssi} dBm)"
               return None
           
           # Parse channel sequence changes
           if "changed channel sequence" in line:
               seq_match = re.search(r'peer ([a-f0-9:]{17}) \([^)]+\) changed channel sequence to (.+)', line)
               if seq_match:
                   mac = seq_match.group(1)
                   sequence = seq_match.group(2)
                   return f"📡 CHANNEL SEQ: {mac} → {sequence}"
           
           # Parse peer removal/addition
           if "remove peer" in line:
               peer_match = re.search(r'remove peer ([a-f0-9:]{17})', line)
               if peer_match:
                   mac = peer_match.group(1)
                   if mac in known_peers:
                       duration = time.time() - known_peers[mac]['first_seen']
                       del known_peers[mac]
                       return f"👋 PEER LEFT: {mac} (was active {duration:.1f}s)"
           
           # Parse sync errors
           if "Sync error" in line:
               error_match = re.search(r'Sync error (\d+) TU \(([^)]+)\)', line)
               if error_match:
                   tu = error_match.group(1)
                   percent = error_match.group(2)
                   return f"⚠️  SYNC ERROR: {tu} TU ({percent})"
           
           # Pass through INFO/WARN/ERROR messages
           if any(level in line for level in ["INFO", "WARN", "ERROR"]):
               return line.strip().split(":", 2)[-1].strip() if ":" in line else line.strip()
           
           return None
       
       # Start OWL wrapper in background thread
       owl_thread = threading.Thread(target=run_owl_wrapper, daemon=True)
       owl_thread.start()
       
       print("OWL AWDL Monitor started successfully!")
       print("Monitoring AWDL traffic and filtering out noise...")
       print("Only meaningful AWDL events will be displayed")
       
       # Store the cleanup function globally for exit handler
       def cleanup_owl():
           try:
               if hasattr(run_owl_wrapper, 'processes'):
                   print("Cleaning up OWL processes...")
                   for proc in run_owl_wrapper.processes:
                       if proc.poll() is None:  # Process still running
                           proc.terminate()
                           proc.wait(timeout=5)
           except Exception as e:
               print(f"Cleanup error: {e}")
       
       # Register cleanup function
       import atexit
       atexit.register(cleanup_owl)
       
   except Exception as e:
       print(f"Failed to start OpenDrop receiver: {e}")
       print("Falling back to basic BLE monitoring only...")

def start_listetninig():
   """Legacy function - now redirects to proper OpenDrop receiver"""
   start_airdrop_receiver()


def adv_airdrop():
   while True:
       dev_id = 0
       toggle_device(dev_id, True)
       header = (0x02, 0x01, 0x1a, 0x1b, 0xff, 0x4c, 0x00)
       data1 = (0x05, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01)
       apple_id = (0x00, 0x00)
       phone = (0x00, 0x00)
       email = (0xb7, 0x9b)
       data2 = (0x00, 0x00, 0x00, 0x10, 0x02, 0x0b, 0x00)
       try:
           sock = bluez.hci_open_dev(dev_id)
       except:
           print("Cannot open bluetooth device %i" % dev_id)
           raise
       start_le_advertising(sock, adv_type=0x02, min_interval=500, max_interval=500,
                            data=(header + data1 + apple_id + phone + email + data2))
       time.sleep(10)
       stop_le_advertising(sock)


def print_results3(data):
   if not len(data):
       return ''
   u_data = []
   for dev in data:
       if dev not in u_data:
           u_data.append(dev)
   x = PrettyTable()
   x.field_names = ["Name", "Host", "OS", "Discoverable", 'Address']
   for dev in u_data:
       x.add_row([dev['name'], dev['host'], dev['os'], dev['discoverable'], dev['address']])
   return x.get_string()


# New globals for capture management
owl_proc = None
capture_running = False

connected_macs = set()
real_mac_log = "awdl_connected_macs.log"
last_capture_time = {}
capture_cooldown = 60
capture_proc = None
pcap_file = "awdl_handshake_capture.pcap"

# Rate limiting for AirDrop detection messages
last_airdrop_message_time = {}
airdrop_message_cooldown = 10  # seconds between messages per MAC

def start_awdl_capture():
    global capture_proc, capture_running
    
    if args.airdrop:
        if not hasattr(start_awdl_capture, 'airdrop_skip_message_shown'):
            print(f"[{time.strftime('%H:%M:%S')}] AirDrop mode active - skipping AWDL capture to maintain connectivity")
            start_awdl_capture.airdrop_skip_message_shown = True
        return
    
    if capture_running:
        print(f"[{time.strftime('%H:%M:%S')}] AWDL capture already running, skipping...")
        return
    
    print(f"[{time.strftime('%H:%M:%S')}] Starting tshark for AWDL capture (OWL must be running separately)...")
    
    try:
        # Prepare interface
        subprocess.run(['sudo', 'systemctl', 'stop', 'NetworkManager'], 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.run(['sudo', 'killall', 'wpa_supplicant'], 
                      stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        subprocess.run(['sudo', 'iw', 'dev', args.interface, 'set', 'type', 'monitor'], 
                      check=True)
        subprocess.run(['sudo', 'ip', 'link', 'set', args.interface, 'up'], 
                      check=True)
        
        # Use tshark to capture AWDL Action Frames
        capture_proc = subprocess.Popen(['sudo', 'tshark', '-i', args.interface, 
                                       '-f', 'wlan type mgt subtype 0xd0', 
                                       '-w', pcap_file],
                                       stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
        
        capture_running = True
        print(f"[{time.strftime('%H:%M:%S')}] Capture started, saving to {pcap_file}")
        
        # Schedule stop
        Thread(target=stop_awdl_capture, args=(args.capture_duration,)).start()
    except Exception as e:
        print(f"[{time.strftime('%H:%M:%S')}] Error starting AWDL capture: {e}")
        capture_running = False
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Capture error: {e}\n")

# Replace stop_awdl_capture()
def stop_awdl_capture(duration):
    time.sleep(duration)
    global capture_proc, capture_running
    if capture_proc:
        try:
            os.kill(capture_proc.pid, signal.SIGTERM)
            capture_proc.wait(timeout=5)
            print(f"[{time.strftime('%H:%M:%S')}] Capture stopped after {duration}s")
        except Exception as e:
            print(f"[{time.strftime('%H:%M:%S')}] Error stopping capture: {e}")
            with open(real_mac_log, 'a') as f:
                f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Stop capture error: {e}\n")
        capture_proc = None
    capture_running = False
    if os.path.exists(pcap_file) and os.path.getsize(pcap_file) > 0:
        print(f"[{time.strftime('%H:%M:%S')}] Analyzing {pcap_file}...")
        analyze_pcap()
    else:
        print(f"[{time.strftime('%H:%M:%S')}] No pcap file or empty, skipping analysis")
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] No pcap file or empty\n")

# Replace analyze_pcap()
def analyze_pcap():
    if not os.path.exists(pcap_file) or os.path.getsize(pcap_file) == 0:
        print(f"[{time.strftime('%H:%M:%S')}] Error: {pcap_file} is empty or missing")
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] Error: Pcap empty or missing\n")
        return
    
    try:
        # Check packet count
        packet_count = subprocess.check_output(['tshark', '-r', pcap_file, '-T', 'fields', '-e', 'frame.number']).decode().strip()
        packet_count = len(packet_count.split('\n')) if packet_count else 0
        print(f"[{time.strftime('%H:%M:%S')}] Pcap contains {packet_count} packets")
        
        # Extract AWDL-specific data
        hostnames = subprocess.check_output(['tshark', '-r', pcap_file, '-Y', 'awdl.tlv.type == 10', '-T', 'fields', '-e', 'awdl.tlv.data']).decode().strip()
        chanseq = subprocess.check_output(['tshark', '-r', pcap_file, '-Y', 'awdl.tlv.type == 1', '-T', 'fields', '-e', 'awdl.tlv.data']).decode().strip()
        macs = subprocess.check_output(['tshark', '-r', pcap_file, '-Y', 'awdl', '-T', 'fields', '-e', 'wlan.sa']).decode().strip()
        
        real_macs = list(set(macs.split('\n'))) if macs else []
        analysis = (f"Packet Count: {packet_count}\n"
                   f"Connected BLE MACs: {', '.join(connected_macs) or 'None'}\n"
                   f"Real MACs: {', '.join(real_macs) or 'None'}\n"
                   f"Hostnames: {hostnames or 'None'}\n"
                   f"Channel Sequences: {chanseq or 'None'}")
        print(f"[{time.strftime('%H:%M:%S')}] {analysis}")
        
        # Log to file
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] AWDL Analysis:\n{analysis}\n")
            f.write(f"Note: Correlate BLE and real MACs via timing or device testing.\n")
            mitigations = "Mitigations: Disable AirDrop/AWDL; Randomize hostnames; Enable WiFi MAC randomization."
            f.write(f"{mitigations}\n")
            f.write("-" * 50 + "\n")
        
        if args.verb:
            with open(logFile, 'a+') as f:
                f.write(f"AWDL Analysis: {analysis}\n")
    except subprocess.CalledProcessError as e:
        print(f"[{time.strftime('%H:%M:%S')}] tshark error: {e}")
        with open(real_mac_log, 'a') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] tshark error: {e}\n")

if args.ssid:
   thread_ssid = Thread(target=get_ssids, args=())
   thread_ssid.daemon = True
   thread_ssid.start()


if args.airdrop:
   thread2 = Thread(target=start_listetninig, args=())
   thread2.daemon = True
   thread2.start()
   thread3 = Thread(target=adv_airdrop, args=())
   thread3.daemon = True
   thread3.start()
   # Capture will be triggered by BLE events


logFile = None
if args.verb:
   logFile = '/tmp/apple_bleee_{}'.format(random.randint(1, 3000))


init_bluez()
thread1 = Thread(target=do_sniff, args=(False,))
thread1.daemon = True
thread1.start()
MyApp = App()
MyApp.run()
thread1.join()


# Cleanup capture on exit
if capture_running:
   stop_awdl_capture(0)
